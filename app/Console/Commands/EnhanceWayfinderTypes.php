<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Facades\File;
use ReflectionClass;

class EnhanceWayfinderTypes extends Command
{
    protected $signature = 'wayfinder:enhance-types';

    protected $description = 'Enhance Wayfinder generated files with TypeScript types from FormRequest validation rules';

    public function handle(): int
    {
        $this->info('Enhancing Wayfinder types with FormRequest validation rules...');

        $actionsPath = resource_path('js/actions');
        $typesPath = resource_path('js/types');

        if (! File::exists($typesPath)) {
            File::makeDirectory($typesPath, 0755, true);
        }

        $this->generateTypesFromFormRequests($typesPath);
        $this->enhanceWayfinderControllers($actionsPath, $typesPath);

        $this->info('Done!');

        return Command::SUCCESS;
    }

    protected function generateTypesFromFormRequests(string $typesPath): void
    {
        $formRequests = $this->findFormRequests();
        $types = [];

        foreach ($formRequests as $formRequest) {
            $typeName = $this->getTypeName($formRequest);
            $typeDefinition = $this->convertRulesToTypeScript($formRequest);

            if ($typeDefinition) {
                $types[$typeName] = $typeDefinition;
            }
        }

        $content = "/**\n * Auto-generated TypeScript types from FormRequest validation rules\n * Generated by: php artisan wayfinder:enhance-types\n */\n\n";
        $content .= "export type RequestBodyTypes = {\n";

        foreach ($types as $typeName => $definition) {
            $content .= "    {$typeName}: {$definition};\n";
        }

        $content .= "};\n\n";

        foreach ($types as $typeName => $definition) {
            $content .= "export type {$typeName} = {$definition};\n\n";
        }

        File::put($typesPath.'/requests.ts', $content);
        $this->info("Generated types file: {$typesPath}/requests.ts");
    }

    protected function enhanceWayfinderControllers(string $actionsPath, string $typesPath): void
    {
        $controllerFiles = File::allFiles($actionsPath);

        foreach ($controllerFiles as $file) {
            if (! str_ends_with($file->getFilename(), 'Controller.ts')) {
                continue;
            }

            $content = File::get($file->getPathname());
            $controllerName = $file->getFilenameWithoutExtension();

            // Find corresponding FormRequest
            $formRequest = $this->findFormRequestForController($controllerName);

            if (! $formRequest) {
                continue;
            }

            $typeName = $this->getTypeName($formRequest);
            $method = $this->getHttpMethod($content);

            if (! in_array($method, ['post', 'put', 'patch'])) {
                continue;
            }

            // Check if already enhanced
            if (str_contains($content, 'postWithBody') || str_contains($content, 'putWithBody') || str_contains($content, 'patchWithBody')) {
                continue;
            }

            $enhancedContent = $this->addTypedMethod($content, $method, $typeName, $typesPath);
            File::put($file->getPathname(), $enhancedContent);
            $this->info("Enhanced: {$file->getRelativePathname()}");
        }
    }

    protected function addTypedMethod(string $content, string $method, string $typeName, string $typesPath): string
    {
        $relativeTypesPath = $this->getRelativePath($typesPath);
        $importStatement = "import type { {$typeName} } from '{$relativeTypesPath}/requests';\n";

        // Add import if not exists
        if (! str_contains($content, "from '{$relativeTypesPath}/requests'")) {
            $firstImportPos = strpos($content, 'import ');
            if ($firstImportPos !== false) {
                $nextLinePos = strpos($content, "\n", $firstImportPos);
                $content = substr_replace($content, $importStatement, $nextLinePos + 1, 0);
            }
        }

        // Get controller name from content
        preg_match('/const (\w+Controller) =/', $content, $matches);
        $controllerName = $matches[1] ?? 'Controller';

        $methodName = $method.'WithBody';
        $methodUpper = strtoupper($method);
        $methodDefinition = <<<TS

/**
 * Typed {$methodUpper} method with request body
 * @param body - Request body matching {$typeName} type
 * @param options - Optional route query options
 * @returns Route definition with typed body
 */
{$controllerName}.{$methodName} = (
    body: {$typeName},
    options?: RouteQueryOptions
): RouteDefinition<'{$method}'> & { body: {$typeName} } => ({
    url: {$controllerName}.url(options),
    method: '{$method}',
    body,
})

TS;

        // Add before export statement
        if (str_contains($content, 'export default')) {
            $content = str_replace(
                'export default',
                $methodDefinition."\nexport default",
                $content
            );
        } else {
            $content .= $methodDefinition;
        }

        return $content;
    }

    protected function findFormRequests(): array
    {
        $formRequests = [];
        $featuresPath = app_path('Features');

        $files = File::allFiles($featuresPath);

        foreach ($files as $file) {
            if (! str_ends_with($file->getFilename(), 'Request.php')) {
                continue;
            }

            $className = $this->getClassNameFromFile($file->getPathname());

            if (! $className) {
                continue;
            }

            try {
                $reflection = new ReflectionClass($className);

                if ($reflection->isSubclassOf(FormRequest::class)) {
                    $formRequests[] = $className;
                }
            } catch (\Throwable $e) {
                continue;
            }
        }

        return $formRequests;
    }

    protected function findFormRequestForController(string $controllerName): ?string
    {
        // Map controller names to FormRequest classes
        $mapping = [
            'SendLineMessageController' => 'App\Features\Line\SendLineMessage\SendLineMessageRequest',
            'CreateLineChannelController' => 'App\Features\Line\CreateLineChannel\CreateLineChannelRequest',
            'UpdateLineChannelController' => 'App\Features\Line\UpdateLineChannel\UpdateLineChannelConfigRequest',
            'SendFacebookMessageController' => 'App\Features\Facebook\SendFacebookMessage\SendFacebookMessageRequest',
            'GenerateFacebookConnectUrlController' => 'App\Features\Facebook\GenerateFacebookConnectUrl\GenerateFacebookConnectUrlRequest',
            'FacebookCallbackController' => 'App\Features\Facebook\CreateFacebookChannelOnCallback\HandleFacebookCallbackRequest',
        ];

        if (isset($mapping[$controllerName])) {
            $className = $mapping[$controllerName];

            try {
                $reflection = new ReflectionClass($className);

                if ($reflection->isSubclassOf(FormRequest::class)) {
                    return $className;
                }
            } catch (\Throwable $e) {
                return null;
            }
        }

        return null;
    }

    protected function getClassNameFromFile(string $filePath): ?string
    {
        $content = File::get($filePath);

        if (preg_match('/namespace\s+([^;]+);/', $content, $namespaceMatch) &&
            preg_match('/class\s+(\w+)/', $content, $classMatch)) {
            return $namespaceMatch[1].'\\'.$classMatch[1];
        }

        return null;
    }

    protected function convertRulesToTypeScript(string $formRequestClass): ?string
    {
        try {
            $reflection = new ReflectionClass($formRequestClass);
            $instance = $reflection->newInstanceWithoutConstructor();

            if (! method_exists($instance, 'rules')) {
                return null;
            }

            $rules = $instance->rules();

            if (! is_array($rules)) {
                return null;
            }

            $properties = [];

            foreach ($rules as $field => $rule) {
                $isRequired = $this->isRequired($rule);
                $type = $this->getTypeFromRule($rule);
                $optional = $isRequired ? '' : '?';

                $properties[] = "    {$field}{$optional}: {$type};";
            }

            return "{\n".implode("\n", $properties)."\n}";
        } catch (\Throwable $e) {
            return null;
        }
    }

    protected function isRequired(array|string $rule): bool
    {
        $rules = is_array($rule) ? $rule : [$rule];

        return in_array('required', $rules) || str_contains(implode('|', $rules), 'required');
    }

    protected function getTypeFromRule(array|string $rule): string
    {
        $rules = is_array($rule) ? $rule : explode('|', $rule);
        $rules = array_map('trim', $rules);

        if (in_array('nullable', $rules)) {
            $baseType = $this->getBaseType($rules);
            $inValues = $this->getInValues($rules);

            if ($inValues) {
                return $baseType.' | null';
            }

            return $baseType.' | null';
        }

        $baseType = $this->getBaseType($rules);
        $inValues = $this->getInValues($rules);

        if ($inValues) {
            return $baseType;
        }

        return $baseType;
    }

    protected function getBaseType(array $rules): string
    {
        if (in_array('integer', $rules) || in_array('int', $rules)) {
            return 'number';
        }

        if (in_array('boolean', $rules) || in_array('bool', $rules)) {
            return 'boolean';
        }

        if (in_array('array', $rules)) {
            return 'unknown[]';
        }

        return 'string';
    }

    protected function getInValues(array $rules): ?string
    {
        foreach ($rules as $rule) {
            if (str_starts_with($rule, 'in:')) {
                $values = explode(',', substr($rule, 3));
                $values = array_map(fn ($v) => "'".trim($v)."'", $values);

                return implode(' | ', $values);
            }
        }

        return null;
    }

    protected function getTypeName(string $formRequestClass): string
    {
        $parts = explode('\\', $formRequestClass);
        $className = end($parts);

        return str_replace('Request', '', $className);
    }

    protected function getHttpMethod(string $content): string
    {
        if (preg_match("/method:\s*['\"](post|put|patch|get|delete)['\"]/", $content, $matches)) {
            return $matches[1];
        }

        return 'post';
    }

    protected function getRelativePath(string $absolutePath): string
    {
        $resourcePath = resource_path('js');
        $relative = str_replace($resourcePath, '', $absolutePath);

        return ltrim(str_replace('\\', '/', $relative), '/');
    }
}
